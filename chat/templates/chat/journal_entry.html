
{% extends 'base.html' %} {% block body %}
<style>
.entry-list {
    @apply bg-red bg-opacity-30;
    text-decoration: line-through;
}
</style>

<div class="p-6 flex w-full h-screen bg-foreground">
  <ol class="journal-list" id="journal-list">
  </ol>
  <div class="journal-entry" id="journal-entry">
      <div class="p-4 border rounded">
        <h2 class="p-2 text-xl font-bold" contenteditable="true">Thassles and thives</h2>
        <div id="editor"></div>
      </div>
  </div>
</div>

<!-- 
  this is where quill comes from 
  might be useful to install with npm
  for offline dev
-->
<script src="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.js"></script>
<link href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.snow.css" rel="stylesheet">
<script>
  function create_entry_list_html(entry_id, entry_name) {
    // update the list of titles
    const html = `
      <li class="text-left w-full p-2 hover:bg-gray-100" onclick="update_entry(${entry_id})">
        <button type="submit">
          <p>${entry_name}</p>
        </button>
      </li>
    `;
    const ol = document.getElementById('journal-list');
    ol.insertAdjacentHTML('beforeend', html);
  }

  async function fetch_journal_titles() {
    // get request to list of journals api
    const url = "{% url 'chat:get_journal_titles' %}";
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Response status: ${response.status}`);
      }
      const json = await response.json();
      return json;
    } catch (error) {
      console.error(error.message);
    }
    console.log('hi')
  }

  async function update_titles() {
    // get titles then update list of entries
    // do we need to clear <ol> just in case?
    const titles = await fetch_journal_titles();
    for (const title of titles.entries) {
      create_entry_list_html(title.id, title.entry_name);
    }
  }

  async function fetch_journal_entry(entry_id) {
    // get request to list of journals api
    const url = `{% url 'chat:get_journal_entry' %}?entry_id=${entry_id}`;
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Response status: ${response.status}`);
      }
      const json = await response.json();
      return json;
    } catch (error) {
      console.error(error.message);
    }
    console.log('hi')
  }

  async function update_entry(entry_id) {
    const entry = await fetch_journal_entry(entry_id);
    const html = `
      <div class="p-4 border rounded">
        <h2 class="text-xl font-bold">${entry.entry_name}</h2>
        <p class="mt-2">${entry.text}</p>  
      </div>
    `;
    const div = document.getElementById('journal-entry');
    div.innerHTML = html;
  }

  // main
  update_titles();

  const quill = new Quill('#editor', {
    modules: {
      toolbar: [
        [{header: [1, 2, false]}],
        ['bold', 'italic', 'underline'],
      ]
    },
    placeholder: 'Write here',
    theme: 'snow',
  });

  let log = []; // Array to store deltas
  let deltaBuffer = []; // Temporary buffer to accumulate deltas
  
  // Function to handle text changes
  function handleTextChange(delta) {
    if (delta) {
      deltaBuffer.push(delta); // Accumulate deltas in the buffer
    }
  }
  
  // Attach the handler to the text-change event
  quill.on(Quill.events.TEXT_CHANGE, handleTextChange);
  
  // Function to log deltas every 100ms
  setInterval(() => {
    if (deltaBuffer.length > 0) {
      // Combine all deltas in the buffer into a single delta
      const combinedDelta = deltaBuffer.reduce((acc, curr) => acc.compose(curr));
      log.push(combinedDelta); // Add the combined delta to the log
      console.log('Logged Delta:', combinedDelta); // Log the combined delta
      deltaBuffer = []; // Clear the buffer
    }
  }, 1000); // Run every 100ms

  const Inline = Quill.import('blots/inline');
  
  class ErrorBlot extends Inline {
    static create(message) {
      const node = super.create();
      node.classList.add('ql-error');
  
      const tooltip = document.createElement('span');
      //tooltip.classList.add('ql-error-tooltip');
      tooltip.classList.add('ql-error-tooltip');
      tooltip.textContent = message;
  
      node.appendChild(tooltip);
      return node;
    }
  
    static formats(node) {
      const tooltip = node.querySelector('.ql-error-tooltip');
      return tooltip ? tooltip.textContent : '';
    }
  }
  
  ErrorBlot.blotName = 'error';
  ErrorBlot.tagName = 'span';
  Quill.register(ErrorBlot);
  
  quill.setText('This is some text.');
  quill.formatText(0, 4, 'error', 'This is an error message');

</script>

{% endblock %}
